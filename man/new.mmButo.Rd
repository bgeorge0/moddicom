% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/mmButo.R
\name{new.mmButo}
\alias{new.mmButo}
\title{class for loading multiple sets of DICOM studies from filesystem}
\usage{
new.mmButo(caching = FALSE)
}
\description{
Instantiate an object of the class \code{new.mmButo}. This represents just the classname,
              for each instantiated object many methods are available not i S3 or S4 but by closures method.
              The available methods are:
              \itemize{
              \item \code{void loadCollection(string Path, string collectionID='default')}
              is a method used to open a chosen folder and load all the DICOM studies stored from that.
              each loads refers to a specific collection of studies and new.mmButo can handle multiple
              collections simply addressing those by a label \code{collectionID}. If \code{collectionID}
              is not specified the DICOM studies will be loaded into the \code{collectionID} named 'default'.
              The different loded collections are independent among them.
              \item \code{list getAttribute(string attributeName) }
              This method returns the desided attribute. At the moment the possible attributes are:
              \itemize{
              \item \code{list_geoLet} this attribute contains the list of all the collections containing the
              differents \code{geoLet} object loaded by \code{new.mmButo}.
              Please consider that a \code{names()} on such returned attribute will gave no any valid values
              because of are object built by closures. Each \code{geoLet} object should be handled by with
              its own methods (i.e. \code{...$getAttribute("dataStorage")} or \code{...$getROIList()}, etc..).
              }
              \item \code{list getCollection(collectionID='default')} this methods returns list of geoLet objects,
              exactly as \code{getAttribute("list_geoLet")} does, with the exception that it returns only the list of
              \code{geoLet} objects which refers to the specified collection.
              \item \code{list getROIVoxel(string ROIName, string collectionID)} returns a list of a voxel within
              the indicated ROIs, for the specified collection. If no collection is specified, the default is
              'default'. The returned list contains one element for each loaded study and the voxel cubes are stored
              'cropped' in order ti save memory. Anyway, geometric information of the cropped sub-cube respect the
              biggest voxel cubes are provided. Another option is to use the method \code{...$mmButoLittleCube.expand()}
              to explode the cropped cube to the dimension of the big voxel cube built by CT/MR scans.
              \item \code{list getROIVoxelStats( ROIVoxelList )} it take as parameter a list obtained by the method \code{getROIVoxel()}
              and return some stats. Particularly useful if you have to normalize a signal with the maximum, average or
              minimum value of another signal.
              \item \code{list mmButoLittleCube.expand( ROIVoxelList )} because of \code{..$getROIVoxel()} returns a list of
              voxel cubes cropped around the ROI in order to save memory, can be useful to expand such voxel cube to overlap
              it on the original CT/MR voxel cube correctly for some issues (i.e.: chech the voxel just out the ROI, from the
              external side of the ROI boundaries). In this case, to overlap che cropped voxel cube with the original CT/MR voxel
              cube this method can be used. It takes in input the ROIVoxelList in output from \code{..$getROIVoxel()} and return
              a list with the expanded voxel volumes, ready to be overlapped with CT/MR voxel cubes.

              }
}
\examples{
\dontrun{
# create an object new.mmButo()
obj<-new.mmButo()
obj$loadCollection("/progetti/immagini/carlotta")

# get Urina and GTV
GTV<-obj$getROIVoxel( "GTV" )
Urina<-obj$getROIVoxel( "Urina" )

# build the GTV.corrected which has the GTV  corrected by max value of Urina
GTV.corrected<-obj$getCorrectedROIVoxel(inputROIVoxel = GTV,correctionROIVoxel = Urina)

# plotta le distribuzioni dei GTV (KDF) corretti
RAD.compareSignals(ROIVoxelData = GTV.corrected)

# già che ci sei plotta anche le distribuzioni del'Urina, così da vedere come sono posizionate
# prima correggi per Urina
Urina.corrected<-obj$getCorrectedROIVoxel(inputROIVoxel = Urina,correctionROIVoxel = Urina)
RAD.compareSignals(ROIVoxelData = Urina.corrected)

# feature extraction
# (1) estraiamo le features del primo ordine
feat.fo<-RAD.firstOrderFeatureImage( GTV )

# (2) estraiamo le features di area/volume
feat.av<-RAD.areaVolume( GTV )

# (3)4 estraiamo i centroidi dei carotaggi
feat.ca<-RAD.VirtualBiopsy( ROIVoxelData = GTV,dx.max = 5,dy.max = 5,dz.max = 2,sampleResultAt = 500)

# (4) estraiamo anche un set di ROI del GTV "lontane" dalle regioni di confine, tramite erosione,
# così da neutralizzare eventuali microproblemi di contornazione operatore-dipendente
# (su questi avrà poi senso calcolare media e varianza come facevamo per i carotaggi)
GTV.eroded<-RAD.applyErosion(ROIVoxelData = GTV)

}#' #'
}

